{
  "version": 3,
  "sources": ["../../../../node_modules/mathjax-full/ts/core/DOMAdaptor.ts", "../../../../node_modules/mathjax-full/ts/adaptors/HTMLAdaptor.ts", "../../../../node_modules/mathjax-full/ts/adaptors/browserAdaptor.ts"],
  "sourcesContent": ["/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  The DOMAdaptor interface and abstract class\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {OptionList} from '../util/Options.js';\n\n/**\n * The data for an attribute\n */\nexport type AttributeData = {\n  name: string,\n  value: string\n};\n\n/**\n * The data for an elements page-based bounding box\n */\nexport type PageBBox = {\n  left: number,\n  right: number,\n  top: number,\n  bottom: number\n};\n\n\n/*****************************************************************/\n/**\n *  The interface for the DOMAdaptor\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport interface DOMAdaptor<N, T, D> {\n  /**\n   * Document in which the nodes are to be created\n   */\n  document: D;\n\n  /**\n   * @param {string} text    The serialized document to be parsed\n   * @param {string} format  The format (e.g., 'text/html' or 'text/xhtml')\n   * @return {D}             The parsed document\n   */\n  parse(text: string, format?: string): D;\n\n  /**\n   * @param {string} kind      The tag name of the HTML node to be created\n   * @param {OptionList} def   The properties to set for the created node\n   * @param {(N|T)[]} children The child nodes for the created HTML node\n   * @param {string} ns        The namespace in which to create the node\n   * @return {N}               The generated HTML tree\n   */\n  node(kind: string, def?: OptionList, children?: (N | T)[], ns?: string): N;\n\n  /**\n   * @param {string} text   The text from which to create an HTML text node\n   * @return {T}            The generated text node with the given text\n   */\n  text(text: string): T;\n\n  /**\n   * @param {D} doc   The document whose head is to be obtained\n   * @return {N}      The document.head element\n   */\n  head(doc: D): N;\n\n  /**\n   * @param {D} doc   The document whose body is to be obtained\n   * @return {N}      The document.body element\n   */\n  body(doc: D): N;\n\n  /**\n   * @param {D} doc   The document whose documentElement is to be obtained\n   * @return {N}      The documentElement\n   */\n  root(doc: D): N;\n\n  /**\n   * @param {D} doc     The document whose doctype is to be obtained\n   * @return {string}   The DOCTYPE comment\n   */\n  doctype(doc: D): string;\n\n  /**\n   * @param {N} node        The node to search for tags\n   * @param {string} name   The name of the tag to search for\n   * @param {string} ns     The namespace to search in (or null for no namespace)\n   * @return {N[]}          The list of tags found\n   */\n  tags(node: N, name: string, ns?: string): N[];\n\n  /**\n   * Get a list of containers (to be searched for math).  These can be\n   *  specified by CSS selector, or as actual DOM elements or arrays of such.\n   *\n   * @param {(string | N | N[])[]} nodes  The array of items to make into a container list\n   * @param {D} document                  The document in which to search\n   * @return {N[]}                        The array of containers to search\n   */\n  getElements(nodes: (string | N | N[])[], document: D): N[];\n\n  /**\n   * Determine if a container node contains a given node somewhere in its DOM tree\n   *\n   * @param {N} container  The container to search\n   * @param {N|T} node     The node to look for\n   * @return {boolean}     True if the node is in the container's DOM tree\n   */\n  contains(container: N, node: N | T): boolean;\n\n  /**\n   * @param {N|T} node  The HTML node whose parent is to be obtained\n   * @return {N}        The parent node of the given one\n   */\n  parent(node: N | T): N;\n\n  /**\n   * @param {N} node     The HTML node to be appended to\n   * @param {N|T} child  The node or text to be appended\n   * @return {N|T}       The appended node\n   */\n  append(node: N, child: N | T): N | T;\n\n  /**\n   * @param {N|T} nchild  The node or text to be inserted\n   * @param {N|T} ochild  The node or text where the new child is to be added before it\n   */\n  insert(nchild: N | T, ochild: N | T): void;\n\n  /**\n   * @param {N|T} child  The node or text to be removed from its parent\n   * @return {N|T}       The removed node\n   */\n  remove(child: N | T): N | T;\n\n  /**\n   * @param {N|T} nnode  The node to replace with\n   * @param {N|T} onode  The child to be replaced\n   * @return {N|T}       The removed node\n   */\n  replace(nnode: N | T, onode: N | T): N | T;\n\n  /**\n   * @param {N} node   The HTML node to be cloned\n   * @return {N}       The copied node\n   */\n  clone(node: N): N;\n\n  /**\n   * @param {T} node    The HTML text node to be split\n   * @param {number} n  The index of the character where the split will occur\n   */\n  split(node: T, n: number): T;\n\n  /**\n   * @param {N|T} node   The HTML node whose sibling is to be obtained\n   * @return {N|T}       The node following the given one (or null)\n   */\n  next(node: N | T): N | T;\n\n  /**\n   * @param {N|T} node   The HTML node whose sibling is to be obtained\n   * @return {N|T}       The node preceding the given one (or null)\n   */\n  previous(node: N | T): N | T;\n\n  /**\n   * @param {N} node   The HTML node whose child is to be obtained\n   * @return {N|T}     The first child of the given node (or null)\n   */\n  firstChild(node: N): N | T;\n\n  /**\n   * @param {N} node   The HTML node whose child is to be obtained\n   * @return {N}       The last child of the given node (or null)\n   */\n  lastChild(node: N): N | T;\n\n  /**\n   * @param {N} node    The HTML node whose children are to be obtained\n   * @return {(N|T)[]}  Array of children for the given node (not a live list)\n   */\n  childNodes(node: N): (N | T)[];\n\n  /**\n   * @param {N} node    The HTML node whose child is to be obtained\n   * @param {number} i  The index of the child to return\n   * @return {N|T}      The i-th child node of the given node (or null)\n   */\n  childNode(node: N, i: number): N | T;\n\n  /**\n   * @param {N | T} node   The HTML node whose tag or node name is to be obtained\n   * @return {string}      The tag or node name of the given node\n   */\n  kind(node: N | T): string;\n\n  /**\n   * @param {N|T} node  The HTML node whose value is to be obtained\n   * @return {string}   The value of the given node\n   */\n  value(node: N | T): string;\n\n  /**\n   * @param {N} node    The HTML node whose text content is to be obtained\n   * @return {string}   The text content of the given node\n   */\n  textContent(node: N): string;\n\n  /**\n   * @param {N} node   The HTML node whose inner HTML string is to be obtained\n   * @return {string}  The serialized content of the node\n   */\n  innerHTML(node: N): string;\n\n  /**\n   * @param {N} node   The HTML node whose outer HTML string is to be obtained\n   * @return {string}  The serialized node and its content\n   */\n  outerHTML(node: N): string;\n\n  /**\n   * @param {N} node   The HTML node whose serialized string is to be obtained\n   * @return {string}  The serialized node and its content\n   */\n  serializeXML(node: N): string;\n\n  /**\n   * @param {N} node               The HTML node whose attribute is to be set\n   * @param {string|number} name   The name of the attribute to set\n   * @param {string} value         The new value of the attribute\n   * @param {string=} ns           The namespace to use for the attribute\n   */\n  setAttribute(node: N, name: string, value: string | number, ns?: string): void;\n\n  /**\n   * @param {N} node           The HTML element whose attributes are to be set\n   * @param {OptionList} def   The attributes to set on that node\n   */\n  setAttributes(node: N, def: OptionList): void;\n\n  /**\n   * @param {N} node        The HTML node whose attribute is to be obtained\n   * @param {string} name   The name of the attribute to get\n   * @return {string}       The value of the given attribute of the given node\n   */\n  getAttribute(node: N, name: string): string;\n\n  /**\n   * @param {N} node        The HTML node whose attribute is to be removed\n   * @param {string} name   The name of the attribute to remove\n   */\n  removeAttribute(node: N, name: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose attribute is to be tested\n   * @param {string} name   The name of the attribute to test\n   * @return {boolean}      True of the node has the given attribute defined\n   */\n  hasAttribute(node: N, name: string): boolean;\n\n  /**\n   * @param {N} node           The HTML node whose attributes are to be returned\n   * @return {AttributeData[]} The list of attributes\n   */\n  allAttributes(node: N): AttributeData[];\n\n  /**\n   * @param {N} node        The HTML node whose class is to be augmented\n   * @param {string} name   The class to be added\n   */\n  addClass(node: N, name: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose class is to be changed\n   * @param {string} name   The class to be removed\n   */\n  removeClass(node: N, name: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose class is to be tested\n   * @param {string} name   The class to test\n   * @return {boolean}      True if the node has the given class\n   */\n  hasClass(node: N, name: string): boolean;\n\n  /**\n   * @param {N} node        The HTML node whose class list is needed\n   * @return {string[]}     An array of the class names for this node\n   */\n  allClasses(node: N): string[];\n\n  /**\n   * @param {N} node        The HTML node whose style is to be changed\n   * @param {string} name   The style to be set\n   * @param {string} value  The new value of the style\n   */\n  setStyle(node: N, name: string, value: string): void;\n\n  /**\n   * @param {N} node        The HTML node whose style is to be obtained\n   * @param {string} name   The style to be obtained\n   * @return {string}       The value of the style\n   */\n  getStyle(node: N, name: string): string;\n\n  /**\n   * @param {N} node        The HTML node whose styles are to be returned\n   * @return {string}       The cssText for the styles\n   */\n  allStyles(node: N): string;\n\n  /**\n   * @param {N} node           The stylesheet node where the rule will be added\n   * @param {string[]} rules   The rule to add at the beginning of the stylesheet\n   */\n  insertRules(node: N, rules: string[]): void;\n\n  /**\n   * @param {N} node        The HTML node whose font size is to be determined\n   * @return {number}       The font size (in pixels) of the node\n   */\n  fontSize(node: N): number;\n\n  /**\n   * @param {N} node        The HTML node whose font family is to be determined\n   * @return {string}       The font family\n   */\n  fontFamily(node: N): string;\n\n  /**\n   * @param {N} node            The HTML node whose dimensions are to be determined\n   * @param {number} em         The number of pixels in an em\n   * @param {boolean} local     True if local coordinates are to be used in SVG elements\n   * @return {[number, number]} The width and height (in ems) of the element\n   */\n  nodeSize(node: N, em?: number, local?: boolean): [number, number];\n\n\n  /**\n   * @param {N} node            The HTML node whose BBox is to be determined\n   * @return {PageBBox}         BBox as {left, right, top, bottom} position on the page (in pixels)\n   */\n  nodeBBox(node: N): PageBBox;\n}\n\n/*****************************************************************/\n/**\n *  Abstract DOMAdaptor class for creating HTML elements\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport abstract class AbstractDOMAdaptor<N, T, D> implements DOMAdaptor<N, T, D> {\n\n  /**\n   * The document in which the HTML nodes will be created\n   */\n  public document: D;\n\n  /**\n   * @param {D} document  The document in which the nodes will be created\n   * @constructor\n   */\n  constructor(document: D = null) {\n    this.document = document;\n  }\n\n  /**\n   * @override\n   */\n  public abstract parse(text: string, format?: string): D;\n\n  /**\n   * @override\n   */\n  public node(kind: string, def: OptionList = {}, children: (N | T)[] = [], ns?: string) {\n    const node = this.create(kind, ns);\n    this.setAttributes(node, def);\n    for (const child of children) {\n      this.append(node, child);\n    }\n    return node as N;\n  }\n\n  /**\n   * @param {string} kind  The type of the node to create\n   * @param {string} ns    The optional namespace in which to create the node\n   * @return {N}           The created node\n   */\n  protected abstract create(kind: string, ns?: string): N;\n\n  /**\n   * @override\n   */\n  public abstract text(text: string): T;\n\n  /**\n   * @param {N} node           The HTML element whose attributes are to be set\n   * @param {OptionList} def   The attributes to set on that node\n   */\n  public setAttributes(node: N, def: OptionList) {\n    if (def.style && typeof(def.style) !== 'string') {\n      for (let key of Object.keys(def.style)) {\n        this.setStyle(node, key.replace(/-([a-z])/g, (_m, c) => c.toUpperCase()), def.style[key]);\n      }\n    }\n    if (def.properties) {\n      for (let key of Object.keys(def.properties)) {\n        (node as OptionList)[key] = def.properties[key];\n      }\n    }\n    for (let key of Object.keys(def)) {\n      if ((key !== 'style' || typeof(def.style) === 'string') && key !== 'properties') {\n        this.setAttribute(node, key, def[key]);\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  public abstract head(doc: D): N;\n\n  /**\n   * @override\n   */\n  public abstract body(doc: D): N;\n\n  /**\n   * @override\n   */\n  public abstract root(doc: D): N;\n\n  /**\n   * @override\n   */\n  public abstract doctype(doc: D): string;\n\n  /**\n   * @override\n   */\n  public abstract tags(node: N, name: string, ns?: string): N[];\n\n  /**\n   * @override\n   */\n  public abstract getElements(nodes: (string | N | N[])[], document: D): N[];\n\n  /**\n   * @override\n   */\n  public abstract contains(container: N, node: N | T): boolean;\n\n  /**\n   * @override\n   */\n  public abstract parent(node: N | T): N;\n\n  /**\n   * @override\n   */\n  public abstract append(node: N, child: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public abstract insert(nchild: N | T, ochild: N | T): void;\n\n  /**\n   * @override\n   */\n  public abstract remove(child: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public replace(nnode: N | T, onode: N | T) {\n    this.insert(nnode, onode);\n    this.remove(onode);\n    return onode;\n  }\n\n  /**\n   * @override\n   */\n  public abstract clone(node: N):  N;\n\n  /**\n   * @override\n   */\n  public abstract split(node: T, n: number): T;\n\n  /**\n   * @override\n   */\n  public abstract next(node: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public abstract previous(node: N | T): N | T;\n\n  /**\n   * @override\n   */\n  public abstract firstChild(node: N): N | T;\n\n  /**\n   * @override\n   */\n  public abstract lastChild(node: N): N | T;\n\n  /**\n   * @override\n   */\n  public abstract childNodes(node: N): (N | T)[];\n\n  /**\n   * @override\n   */\n  public childNode(node: N, i: number) {\n    return this.childNodes(node)[i];\n  }\n\n  /**\n   * @override\n   */\n  public abstract kind(node: N | T): string;\n\n  /**\n   * @override\n   */\n  public abstract value(node: N | T): string;\n\n  /**\n   * @override\n   */\n  public abstract textContent(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract innerHTML(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract outerHTML(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract serializeXML(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract setAttribute(node: N, name: string, value: string, ns?: string): void;\n\n  /**\n   * @override\n   */\n  public abstract getAttribute(node: N, name: string): string;\n\n  /**\n   * @override\n   */\n  public abstract removeAttribute(node: N, name: string): void;\n\n  /**\n   * @override\n   */\n  public abstract hasAttribute(node: N, name: string): boolean;\n\n\n  /**\n   * @override\n   */\n  public abstract allAttributes(node: N): AttributeData[];\n\n  /**\n   * @override\n   */\n  public abstract addClass(node: N, name: string): void;\n\n  /**\n   * @override\n   */\n  public abstract removeClass(node: N, name: string): void;\n\n  /**\n   * @override\n   */\n  public abstract hasClass(node: N, name: string): boolean;\n\n  /**\n   * @override\n   */\n  public allClasses(node: N) {\n    const classes = this.getAttribute(node, 'class');\n    return (!classes ? [] as string[] :\n            classes.replace(/  +/g, ' ').replace(/^ /, '').replace(/ $/, '').split(/ /));\n  }\n\n  /**\n   * @override\n   */\n  public abstract setStyle(node: N, name: string, value: string): void;\n\n  /**\n   * @override\n   */\n  public abstract getStyle(node: N, name: string): string;\n\n  /**\n   * @override\n   */\n  public abstract allStyles(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract insertRules(node: N, rules: string[]): void;\n\n  /**\n   * @override\n   */\n  public abstract fontSize(node: N): number;\n\n  /**\n   * @override\n   */\n  public abstract fontFamily(node: N): string;\n\n  /**\n   * @override\n   */\n  public abstract nodeSize(node: N, em?: number, local?: boolean): [number, number];\n\n  /**\n   * @override\n   */\n  public abstract nodeBBox(node: N): PageBBox;\n\n}\n", "/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the HTML DOM adaptor\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {OptionList} from '../util/Options.js';\nimport {AttributeData, AbstractDOMAdaptor, DOMAdaptor, PageBBox} from '../core/DOMAdaptor.js';\n\n/*****************************************************************/\n/**\n * The minimum fields needed for a Document\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n */\nexport interface MinDocument<N, T> {\n  documentElement: N;\n  head: N;\n  body: N;\n  title: string;\n  doctype: {name: string};\n  /* tslint:disable:jsdoc-require */\n  createElement(kind: string): N;\n  createElementNS(ns: string, kind: string): N;\n  createTextNode(text: string): T;\n  querySelectorAll(selector: string): ArrayLike<N>;\n  /* tslint:enable */\n}\n\n/*****************************************************************/\n/**\n * The minimum fields needed for an HTML Element\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n */\nexport interface MinHTMLElement<N, T> {\n  nodeType: number;\n  nodeName: string;\n  nodeValue: string;\n  textContent: string;\n  innerHTML: string;\n  outerHTML: string;\n  parentNode: N | Node;\n  nextSibling: N | T | Node;\n  previousSibling: N | T | Node;\n  offsetWidth: number;\n  offsetHeight: number;\n\n  attributes: AttributeData[] | NamedNodeMap;\n  className: string;\n  classList: DOMTokenList;\n  style: OptionList;\n  sheet?: {insertRule: (rule: string, index?: number) => void};\n\n  childNodes: (N | T)[] | NodeList;\n  firstChild: N | T | Node;\n  lastChild: N | T | Node;\n  /* tslint:disable:jsdoc-require */\n  getElementsByTagName(name: string): N[] | HTMLCollectionOf<Element>;\n  getElementsByTagNameNS(ns: string, name: string): N[] | HTMLCollectionOf<Element>;\n  contains(child: N | T): boolean;\n  appendChild(child: N | T): N | T | Node;\n  removeChild(child: N | T): N | T  | Node;\n  replaceChild(nnode: N | T, onode: N | T): N | T  | Node;\n  insertBefore(nchild: N | T, ochild: N | T): void;\n  cloneNode(deep: boolean): N | Node;\n  setAttribute(name: string, value: string): void;\n  setAttributeNS(ns: string, name: string, value: string): void;\n  getAttribute(name: string): string;\n  removeAttribute(name: string): void;\n  hasAttribute(name: string): boolean;\n  getBoundingClientRect(): Object;\n  getBBox?(): {x: number, y: number, width: number, height: number};\n  /* tslint:endable */\n}\n\n/*****************************************************************/\n/**\n * The minimum fields needed for a Text element\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n */\nexport interface MinText<N, T> {\n  nodeType: number;\n  nodeName: string;\n  nodeValue: string;\n  parentNode: N | Node;\n  nextSibling: N | T | Node;\n  previousSibling: N | T | Node;\n  splitText(n: number): T;\n}\n\n/*****************************************************************/\n/**\n * The minimum fields needed for a DOMParser\n *\n * @template D  The Document class\n */\nexport interface MinDOMParser<D> {\n  parseFromString(text: string, format?: string): D;\n}\n\n/*****************************************************************/\n/**\n * The minimum fields needed for a DOMParser\n *\n * @template N  The HTMLElement node class\n */\nexport interface MinXMLSerializer<N> {\n  serializeToString(node: N): string;\n}\n\n/*****************************************************************/\n/**\n * The minimum fields needed for a Window\n *\n * @template N  The HTMLElement node class\n * @template D  The Document class\n */\nexport interface MinWindow<N, D> {\n  document: D;\n  DOMParser: {\n    new(): MinDOMParser<D>\n  };\n  XMLSerializer: {\n    new(): MinXMLSerializer<N>;\n  };\n  NodeList: any;\n  HTMLCollection: any;\n  HTMLElement: any;\n  DocumentFragment: any;\n  Document: any;\n  getComputedStyle(node: N): any;\n}\n\n/*****************************************************************/\n/**\n * The minimum needed for an HTML Adaptor\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport interface MinHTMLAdaptor<N, T, D> extends DOMAdaptor<N, T, D> {\n  window: MinWindow<N, D>;\n}\n\n/*****************************************************************/\n/**\n *  Abstract HTMLAdaptor class for manipulating HTML elements\n *  (subclass of AbstractDOMAdaptor)\n *\n *  N = HTMLElement node class\n *  T = Text node class\n *  D = Document class\n *\n * @template N  The HTMLElement node class\n * @template T  The Text node class\n * @template D  The Document class\n */\nexport class HTMLAdaptor<N extends MinHTMLElement<N, T>, T extends MinText<N, T>, D extends MinDocument<N, T>> extends\nAbstractDOMAdaptor<N, T, D> implements MinHTMLAdaptor<N, T, D> {\n  /**\n   * The window object for this adaptor\n   */\n  public window: MinWindow<N, D>;\n\n  /**\n   * The DOMParser used to parse a string into a DOM tree\n   */\n  public parser: MinDOMParser<D>;\n\n  /**\n   * @override\n   * @constructor\n   */\n  constructor(window: MinWindow<N, D>) {\n    super(window.document);\n    this.window = window;\n    this.parser = new (window.DOMParser as any)();\n  }\n\n  /**\n   * @override\n   */\n  public parse(text: string, format: string = 'text/html') {\n    return this.parser.parseFromString(text, format);\n  }\n\n  /**\n   * @override\n   */\n  protected create(kind: string, ns?: string) {\n    return (ns ?\n            this.document.createElementNS(ns, kind) :\n            this.document.createElement(kind));\n  }\n\n  /**\n   * @override\n   */\n  public text(text: string) {\n    return this.document.createTextNode(text);\n  }\n\n  /**\n   * @override\n   */\n  public head(doc: D) {\n    return doc.head || (doc as any as N);\n  }\n\n  /**\n   * @override\n   */\n  public body(doc: D) {\n    return doc.body || (doc as any as N);\n  }\n\n  /**\n   * @override\n   */\n  public root(doc: D) {\n    return doc.documentElement || (doc as any as N);\n  }\n\n  /**\n   * @override\n   */\n  public doctype(doc: D) {\n    return (doc.doctype ? `<!DOCTYPE ${doc.doctype.name}>` : '');\n  }\n\n  /**\n   * @override\n   */\n  public tags(node: N, name: string, ns: string = null) {\n    let nodes = (ns ? node.getElementsByTagNameNS(ns, name) : node.getElementsByTagName(name));\n    return Array.from(nodes as N[]) as N[];\n  }\n\n  /**\n   * @override\n   */\n  public getElements(nodes: (string | N | N[])[], _document: D) {\n    let containers: N[] = [];\n    for (const node of nodes) {\n      if (typeof(node) === 'string') {\n        containers = containers.concat(Array.from(this.document.querySelectorAll(node)));\n      } else if (Array.isArray(node)) {\n        containers = containers.concat(Array.from(node) as N[]);\n      } else if (node instanceof this.window.NodeList || node instanceof this.window.HTMLCollection) {\n        containers = containers.concat(Array.from(node as any as N[]));\n      } else {\n        containers.push(node);\n      }\n    }\n    return containers;\n  }\n\n  /**\n   * @override\n   */\n  public contains(container: N, node: N | T) {\n    return container.contains(node);\n  }\n\n  /**\n   * @override\n   */\n  public parent(node: N | T) {\n    return node.parentNode as N;\n  }\n\n  /**\n   * @override\n   */\n  public append(node: N, child: N | T) {\n    return node.appendChild(child) as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public insert(nchild: N | T, ochild: N | T) {\n    return this.parent(ochild).insertBefore(nchild, ochild);\n  }\n\n  /**\n   * @override\n   */\n  public remove(child: N | T) {\n    return this.parent(child).removeChild(child) as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public replace(nnode: N | T, onode: N | T) {\n    return this.parent(onode).replaceChild(nnode, onode) as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public clone(node: N) {\n    return node.cloneNode(true) as N;\n  }\n\n  /**\n   * @override\n   */\n  public split(node: T, n: number) {\n    return node.splitText(n);\n  }\n\n  /**\n   * @override\n   */\n  public next(node: N | T) {\n    return node.nextSibling as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public previous(node: N | T) {\n    return node.previousSibling as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public firstChild(node: N) {\n    return node.firstChild as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public lastChild(node: N) {\n    return node.lastChild as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public childNodes(node: N) {\n    return Array.from(node.childNodes as (N | T)[]);\n  }\n\n  /**\n   * @override\n   */\n  public childNode(node: N, i: number) {\n    return node.childNodes[i] as N | T;\n  }\n\n  /**\n   * @override\n   */\n  public kind(node: N | T) {\n    const n = node.nodeType;\n    return (n === 1 || n === 3 || n === 8 ? node.nodeName.toLowerCase() : '');\n  }\n\n  /**\n   * @override\n   */\n  public value(node: N | T) {\n    return node.nodeValue || '';\n  }\n\n  /**\n   * @override\n   */\n  public textContent(node: N) {\n    return node.textContent;\n  }\n\n  /**\n   * @override\n   */\n  public innerHTML(node: N) {\n    return node.innerHTML;\n  }\n\n  /**\n   * @override\n   */\n  public outerHTML(node: N) {\n    return node.outerHTML;\n  }\n\n  public serializeXML(node: N) {\n    const serializer = new this.window.XMLSerializer();\n    return serializer.serializeToString(node) as string;\n  }\n\n  /**\n   * @override\n   */\n  public setAttribute(node: N, name: string, value: string, ns: string = null) {\n    if (!ns) {\n      return node.setAttribute(name, value);\n    }\n    name = ns.replace(/.*\\//, '') + ':' + name.replace(/^.*:/, '');\n    return node.setAttributeNS(ns, name, value);\n  }\n\n  /**\n   * @override\n   */\n  public getAttribute(node: N, name: string) {\n    return node.getAttribute(name);\n  }\n\n  /**\n   * @override\n   */\n  public removeAttribute(node: N, name: string) {\n    return node.removeAttribute(name);\n  }\n\n  /**\n   * @override\n   */\n  public hasAttribute(node: N, name: string) {\n    return node.hasAttribute(name);\n  }\n\n  /**\n   * @override\n   */\n  public allAttributes(node: N) {\n    return Array.from(node.attributes).map(\n      (x: AttributeData) => {\n        return {name: x.name, value: x.value} as AttributeData;\n      }\n    );\n  }\n\n  /**\n   * @override\n   */\n  public addClass(node: N, name: string) {\n    if (node.classList) {\n      node.classList.add(name);\n    } else {\n      node.className = (node.className + ' ' + name).trim();\n    }\n  }\n\n  /**\n   * @override\n   */\n  public removeClass(node: N, name: string) {\n    if (node.classList) {\n      node.classList.remove(name);\n    } else {\n      node.className = node.className.split(/ /).filter((c) => c !== name).join(' ');\n    }\n  }\n\n  /**\n   * @override\n   */\n  public hasClass(node: N, name: string) {\n    if (node.classList) {\n      return node.classList.contains(name);\n    }\n    return node.className.split(/ /).indexOf(name) >= 0;\n  }\n\n  /**\n   * @override\n   */\n  public setStyle(node: N, name: string, value: string) {\n    (node.style as OptionList)[name] = value;\n  }\n\n  /**\n   * @override\n   */\n  public getStyle(node: N, name: string) {\n    return (node.style as OptionList)[name];\n  }\n\n  /**\n   * @override\n   */\n  public allStyles(node: N) {\n    return node.style.cssText;\n  }\n\n  /**\n   * @override\n   */\n  public insertRules(node: N, rules: string[]) {\n    for (const rule of rules.reverse()) {\n      try {\n        node.sheet.insertRule(rule, 0);\n      } catch (e) {\n        console.warn(`MathJax: can't insert css rule '${rule}': ${e.message}`);\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  public fontSize(node: N) {\n    const style = this.window.getComputedStyle(node);\n    return parseFloat(style.fontSize);\n  }\n\n  /**\n   * @override\n   */\n  public fontFamily(node: N) {\n    const style = this.window.getComputedStyle(node);\n    return style.fontFamily || '';\n  }\n\n  /**\n   * @override\n   */\n  public nodeSize(node: N, em: number = 1, local: boolean = false) {\n    if (local && node.getBBox) {\n      let {width, height} = node.getBBox();\n      return [width / em , height / em] as [number, number];\n    }\n    return [node.offsetWidth / em, node.offsetHeight / em] as [number, number];\n  }\n\n  /**\n   * @override\n   */\n  public nodeBBox(node: N) {\n    const {left, right, top, bottom} = node.getBoundingClientRect() as PageBBox;\n    return {left, right, top, bottom};\n  }\n}\n", "/*************************************************************\n *\n *  Copyright (c) 2018-2022 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the browser DOM adaptor\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {HTMLAdaptor} from './HTMLAdaptor.js';\n\n//\n//  Let Typescript know about these\n//\ndeclare global {\n  interface Window {\n    Document: typeof Document;\n    DOMParser: typeof DOMParser;\n    XMLSerializer: typeof XMLSerializer;\n    HTMLElement: typeof HTMLElement;\n    HTMLCollection: typeof HTMLCollection;\n    NodeList: typeof NodeList;\n    DocumentFragment: typeof DocumentFragment;\n  }\n}\n\n/**\n * Function to create an HTML adpator for browsers\n *\n * @return {HTMLAdaptor}  The newly created adaptor\n */\nexport function browserAdaptor(): HTMLAdaptor<HTMLElement, Text, Document> {\n  return new HTMLAdaptor<HTMLElement, Text, Document>(window);\n}\n"],
  "mappings": "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",
  "names": ["AbstractDOMAdaptor", "HTMLAdaptor", "window"]
}
